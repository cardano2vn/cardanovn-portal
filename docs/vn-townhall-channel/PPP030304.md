1
00:00:00,050 --> 00:00:07,290
One of my colleagues at input output
bought some ADA for his nephews and nieces.

2
00:00:07,770 --> 00:00:10,830
And of course, I don't know any details about that.

3
00:00:11,400 --> 00:00:16,590
But just imagine you want to
make a gift of ADA to a child.

4
00:00:17,280 --> 00:00:24,494
So, you want the child to own the ADA, but
you only want the child to have access to the

5
00:00:24,494 --> 00:00:28,794
ADA when he or she turns 18 or 21 or whatever.

6
00:00:29,914 --> 00:00:37,545
And using Plutus, this is very easy to implement
a scheme like that, a vesting scheme like that.

7
00:00:37,995 --> 00:00:41,265
So I copied the is data contract.

8
00:00:41,325 --> 00:00:45,315
And into a new module that I called vesting.

9
00:00:46,095 --> 00:00:53,655
And as our first example of a validator
that actually uses the context, I want

10
00:00:53,655 --> 00:00:57,285
to try to implement this vesting idea.

11
00:00:58,105 --> 00:01:04,920
So you put money into a script and only the
dedicated person can retrieve it, but only

12
00:01:04,920 --> 00:01:07,230
once a certain deadline has been reached.

13
00:01:08,610 --> 00:01:14,520
So the first step is to think about
the types of datum and redeemer.

14
00:01:16,140 --> 00:01:23,100
And it makes sense to have the datum contain
exactly those two pieces of information,

15
00:01:23,460 --> 00:01:25,780
the beneficiary and the deadline.

16
00:01:26,804 --> 00:01:30,755
So let's do what we did at the end of last lecture.

17
00:01:30,785 --> 00:01:35,414
Use a custom type for the datum,
I called it vesting datum.

18
00:01:35,985 --> 00:01:39,914
It's a simple record type with these
two fields, beneficiary and deadline.

19
00:01:40,725 --> 00:01:42,824
And what should the data types be?

20
00:01:42,824 --> 00:01:51,405
Well the beneficiary will be identified by his
or her public key or rather public key hash or

21
00:01:51,405 --> 00:01:54,265
to be even more precise, payment public key hash.

22
00:01:54,875 --> 00:01:59,490
So that will be the hash of his public payment key.

23
00:02:00,690 --> 00:02:06,510
And the deadline, as we saw before
Plutus uses real time, POSIX time.

24
00:02:07,680 --> 00:02:08,710
So this is the datum.

25
00:02:09,780 --> 00:02:14,560
And we can derive a show instance,
which maybe useful for debugging.

26
00:02:14,790 --> 00:02:20,130
So that we can display values
of this type in the console.

27
00:02:21,280 --> 00:02:26,350
And as I also explained last time, we
don't have to write to data or from data

28
00:02:26,400 --> 00:02:31,260
instances by hand, we can use template
Haskell with this unstable make is data.

29
00:02:31,320 --> 00:02:35,730
Although in production, we would probably
not use the unstable, but the stable version.

30
00:02:35,790 --> 00:02:39,310
But for simplicity, we can just do it like this.

31
00:02:41,180 --> 00:02:44,010
Now the interesting part is the validator function.

32
00:02:45,119 --> 00:02:51,329
And as we know, it takes the datum, the
redeemer, the context and returns a bool if

33
00:02:51,329 --> 00:02:55,440
we use typed Plutus, which we want to do.

34
00:02:56,399 --> 00:02:58,469
So we just talked about the datum type.

35
00:02:58,679 --> 00:03:02,160
We use our custom vesting datum for that.

36
00:03:02,880 --> 00:03:04,200
So what about the redeemer?

37
00:03:04,230 --> 00:03:10,859
So the question is, does the beneficiary
need any additional information when he wants

38
00:03:10,859 --> 00:03:16,050
to redeem the gift, the deposited money.

39
00:03:16,829 --> 00:03:19,740
And in this case, I think we don't
need any additional information.

40
00:03:20,010 --> 00:03:25,860
So all the beneficiary has to do is once the
deadline has been reached, just try to unlock

41
00:03:26,730 --> 00:03:31,170
the UTxO sitting at the vesting script address.

42
00:03:31,680 --> 00:03:37,290
So there is no additional information needed
as long as the beneficiary signs a transaction.

43
00:03:37,290 --> 00:03:43,710
And as long as the deadline has been reached,
the funds should be his and should be possible

44
00:03:43,710 --> 00:03:49,350
for him to use an output sitting at this vesting
address, as an input for his transaction and

45
00:03:49,350 --> 00:03:51,960
then do with it whatever he or she wants.

46
00:03:52,859 --> 00:03:59,400
Which means, so the first argument, the datum must
be of type vesting datum and the second argument,

47
00:03:59,400 --> 00:04:01,769
the redeem we don't need any additional information.

48
00:04:02,070 --> 00:04:04,140
So we can just use the unit type.

49
00:04:04,769 --> 00:04:08,070
And the third argument is of type, script context.

50
00:04:09,929 --> 00:04:12,179
And we can give names.

51
00:04:12,179 --> 00:04:19,469
So we call the datum dat, the redeemer will always
be unit because that's the only value of type unit.

52
00:04:20,909 --> 00:04:23,160
And this time we actually
have to look at the context.

53
00:04:23,160 --> 00:04:26,940
So we can just use an underscore
as we did in our previous examples.

54
00:04:27,420 --> 00:04:31,500
So we give the context a
name as well, we call it ctx.

55
00:04:33,255 --> 00:04:39,164
Okay, and under which conditions should it
be possible to unlock a UTxO sitting at this

56
00:04:39,525 --> 00:04:46,635
address, whether as I said before, the transaction
that unlocks must be signed by the beneficiary

57
00:04:47,205 --> 00:04:49,934
and the deadline must have been reached.

58
00:04:51,255 --> 00:04:56,895
So I'm using this trace if false again,
to, if something goes wrong, to give

59
00:04:56,895 --> 00:05:02,789
some debbug information or tracing
information about the costs of the failure.

60
00:05:03,570 --> 00:05:07,530
So this is the first condition we want
to check that the beneficiary signed.

61
00:05:08,099 --> 00:05:12,780
So we just give this debbug information
in case something went wrong.

62
00:05:12,780 --> 00:05:15,900
This condition was not satisfied,
beneficiary's signature missing.

63
00:05:16,469 --> 00:05:21,000
And then delegate the actual logic to a
helper function signed by a beneficiary.

64
00:05:21,990 --> 00:05:25,740
And additionally we've wanted
the deadline has been reached.

65
00:05:25,800 --> 00:05:30,000
So we will define a second helper
function, deadline reached.

66
00:05:30,120 --> 00:05:35,340
And if it hasn't been reached the given
appropriate message, deadline not reached.

67
00:05:36,854 --> 00:05:40,905
So let's look at these helper
functions, they are refreshingly short.

68
00:05:42,315 --> 00:05:48,995
So first we need this Tx info field of the
script context and we need that more than once.

69
00:05:48,995 --> 00:05:52,945
So I extracted that, so I defined that first here.

70
00:05:52,995 --> 00:05:57,284
So info is just the Tx info
field of the script context.

71
00:05:58,575 --> 00:06:03,690
And now we have to implement these two conditions,
signed by beneficiary, deadline reached.

72
00:06:04,380 --> 00:06:09,810
So signed by beneficiary, there's actually
a helper function called Tx signed by that

73
00:06:09,810 --> 00:06:13,200
takes a Tx info, which we have defined here.

74
00:06:14,460 --> 00:06:16,800
And it takes a public key hash.

75
00:06:17,550 --> 00:06:24,330
And the meaning obviously is that this is
true if and only if the transaction has

76
00:06:24,330 --> 00:06:29,830
been signed by the owner of this public
key hash, that's the second argument.

77
00:06:31,230 --> 00:06:39,060
We do have the required signature, the public key
hash in the form of the beneficiary of the datum.

78
00:06:39,210 --> 00:06:43,140
So we just grab that, so this field.

79
00:06:43,160 --> 00:06:46,740
So now we have this payment pub
key hash of the beneficiary.

80
00:06:47,550 --> 00:06:52,920
Unfortunately, the Tx signed by doesn't expect the
payment pub key hash, but just the pub key hash.

81
00:06:53,516 --> 00:06:57,990
But if we look at the definition
of payment pub key hash.

82
00:07:00,180 --> 00:07:07,740
Then here we see it's simply a
newtype wrapper around a pub key hash.

83
00:07:08,430 --> 00:07:14,640
So there's just for type safety that we don't
confuse different types of pub key hashes,

84
00:07:14,640 --> 00:07:18,600
but the underlying data representation is
actually the same, is just the pub key hash.

85
00:07:19,230 --> 00:07:25,230
Which means that by applying unpayment
pub key hash to our payment pub key hash

86
00:07:25,230 --> 00:07:28,125
we get to the underlying pub key hash.

87
00:07:29,445 --> 00:07:37,835
So this, so we have the datum, the beneficiary gives
us this first field, type payment pub key hash.

88
00:07:38,355 --> 00:07:43,695
Then by applying unpayment pub key hash we
get a pub key hash and that we can pass a

89
00:07:43,695 --> 00:07:46,215
second argument to the Tx signed by function.

90
00:07:46,635 --> 00:07:48,295
That's exactly what we want.

91
00:07:49,425 --> 00:07:53,730
Other more interesting condition is
the second one, deadline reached.

92
00:07:54,190 --> 00:07:58,950
If we look at this crew diagram, so this
is time and let's say the deadline is here.

93
00:07:59,790 --> 00:08:02,040
And let's consider a transaction with...

94
00:08:02,400 --> 00:08:05,020
let's first say this validity interval.

95
00:08:06,030 --> 00:08:11,765
So recall what that means, before
the validator script is run.

96
00:08:12,815 --> 00:08:15,034
Other checks are made including the time check.

97
00:08:15,065 --> 00:08:21,695
So the node checks whether the current time
falls into the valid range of the transaction.

98
00:08:22,025 --> 00:08:24,065
And only then it's the validator run.

99
00:08:24,455 --> 00:08:30,305
So we know now that we in the validator, the current
time lives somewhere in the validity interval.

100
00:08:30,844 --> 00:08:34,145
But if this here, the first one
would be the validity interval.

101
00:08:34,325 --> 00:08:37,055
Then the current time could be, for example, here.

102
00:08:37,265 --> 00:08:40,715
Which would be fine, that would be
after the deadline, but it could also

103
00:08:40,715 --> 00:08:42,424
be here, which would not be fine.

104
00:08:42,424 --> 00:08:43,594
That would be before the deadline.

105
00:08:43,595 --> 00:08:46,235
So this validity interval is not good for us.

106
00:08:46,985 --> 00:08:52,205
We mustn't declare the transaction to be
valid if this is the validity interval.

107
00:08:52,825 --> 00:08:54,335
This on the other hand is fine.

108
00:08:54,425 --> 00:08:58,525
We still don't know where the current time
exactly is, it can be anywhere in this interval.

109
00:08:59,045 --> 00:09:01,745
But no matter where it is after the deadline.

110
00:09:02,345 --> 00:09:04,085
So we must check that we have this situation.

111
00:09:04,730 --> 00:09:07,880
That the whole interval is
to the right of the deadline.

112
00:09:08,390 --> 00:09:13,340
And one way to do is, is to use this contains
function that we played with earlier.

113
00:09:14,360 --> 00:09:18,410
And, look at this interval, the half
open interval that starts at the

114
00:09:18,410 --> 00:09:20,390
deadline and stretches into infinity.

115
00:09:20,689 --> 00:09:26,130
And if this interval contains the validity
interval of the transaction, then we are good.

116
00:09:26,820 --> 00:09:30,990
Then we know no matter where the current
time is, it will be after the deadline.

117
00:09:31,440 --> 00:09:39,180
So we know the deadline is the second field from our
datum which we can get with the deadline accessor.

118
00:09:39,240 --> 00:09:40,950
So this is now the deadline.

119
00:09:42,315 --> 00:09:48,735
And we have the info valid range that we
discussed earlier from the transaction

120
00:09:48,825 --> 00:09:51,005
that we get from the Tx info field.

121
00:09:51,705 --> 00:09:59,215
And as long as the current time interval is
contained in this one, we can be sure that

122
00:09:59,215 --> 00:10:05,745
no matter what the actual current time is,
it will definitely be after the deadline.

123
00:10:05,835 --> 00:10:06,885
And that's what we want.

124
00:10:07,875 --> 00:10:12,314
So this is a way to define
this deadline reach condition.

125
00:10:13,005 --> 00:10:17,685
And we have the signed by beneficiary
and the combination of the two logical

126
00:10:17,685 --> 00:10:20,715
and gives us the logic we want.

127
00:10:21,015 --> 00:10:28,365
So a UTxO sitting at this vesting address
can only be unlocked by a transaction

128
00:10:28,365 --> 00:10:33,435
that has been signed by the beneficiary
and where the deadline has been reached.

129
00:10:34,800 --> 00:10:41,370
As always the validator is the heart
of the Plutus smart contract that

130
00:10:41,370 --> 00:10:42,960
contains the actual business logic.

131
00:10:43,620 --> 00:10:49,140
But in addition to that, as we have learned
last week, it needs some boiler plate.

132
00:10:49,530 --> 00:10:55,590
So as I explained when I talked
about typed Plutus contracts.

133
00:10:56,460 --> 00:11:02,025
We need this dummy type, I in this case
called it vesting where we encode the

134
00:11:02,055 --> 00:11:04,345
types of the datum and the redeemer.

135
00:11:04,345 --> 00:11:07,005
So in our case vesting, datum and unit.

136
00:11:07,965 --> 00:11:16,035
And then just following the same schema that
we introduced last week, we can compile our

137
00:11:16,035 --> 00:11:22,604
Haskell code to an actual Plutus validator,
typed validator like this, following the

138
00:11:22,604 --> 00:11:25,574
same process that we learn last time.

139
00:11:26,234 --> 00:11:31,964
And once we have that, we can get the
untyped validator and the validator hash.

140
00:11:32,354 --> 00:11:39,974
And the address, the actual address corresponding
to this script, to this validator as last week.

141
00:11:40,845 --> 00:11:48,285
And I should also mentioned that at the top of the
module, I added some additional GHC extensions,

142
00:11:48,285 --> 00:11:50,405
like derive any class and drive generic.

143
00:11:51,725 --> 00:11:57,825
And I also added some imports, like
to json, from json, generic and so on.

144
00:11:59,955 --> 00:12:02,445
So let's briefly look at the off-chain part.

145
00:12:03,015 --> 00:12:09,555
So, this type here, vesting schema defines the
endpoints that we want to expose to the user.

146
00:12:10,125 --> 00:12:17,185
And as before in our silly example from
last week, called them give and grab.

147
00:12:17,225 --> 00:12:22,905
So give is for the person that wants to
set up this vesting contract and then

148
00:12:22,905 --> 00:12:25,155
grab for the beneficiary to collect.

149
00:12:26,145 --> 00:12:28,125
So what parameters do we need?

150
00:12:29,295 --> 00:12:37,350
For give, I mean, what this endpoint will do,
is it will create a UTxO at the vesting address

151
00:12:37,950 --> 00:12:41,600
with the specified amount and the correct datum.

152
00:12:41,730 --> 00:12:46,170
And if you recall our vesting datum
contains the beneficiary and the deadline.

153
00:12:46,800 --> 00:12:51,990
So, this give endpoint must in particular
know those, the beneficiary and the deadline.

154
00:12:52,230 --> 00:12:53,370
So this is here.

155
00:12:54,090 --> 00:12:58,600
And we also of course, have to specify how
much money we want to put at this UTxO.

156
00:12:58,650 --> 00:13:01,330
Therefore I need the third field, the amount.

157
00:13:03,030 --> 00:13:06,780
The grab endpoint on the other
hand, doesn't need any parameters.

158
00:13:07,530 --> 00:13:15,959
Because the beneficiary will just look
for UTxOs sitting at the vesting address.

159
00:13:16,800 --> 00:13:20,219
And then can check whether he is the beneficiary.

160
00:13:20,670 --> 00:13:22,770
And whether the deadline has already passed.

161
00:13:23,550 --> 00:13:28,140
And can then pick those UTxOs and consume them.

162
00:13:28,830 --> 00:13:33,720
And we know from the way that we wrote the
validator, that that will then succeed and

163
00:13:34,320 --> 00:13:36,870
no additional information has to be supplied.

164
00:13:37,410 --> 00:13:39,340
Let's briefly look at the endpoints.

165
00:13:39,360 --> 00:13:40,380
First at give.

166
00:13:41,130 --> 00:13:42,870
So it takes the give parameters.

167
00:13:44,580 --> 00:13:46,830
And first I compute the datum I want to use.

168
00:13:46,980 --> 00:13:52,050
So recall I need the beneficiary and
the deadline, and I can get those simply

169
00:13:52,110 --> 00:13:54,930
from reading it from the give parameters.

170
00:13:55,860 --> 00:14:01,680
Now for the transaction, I need as constraint
that I want to create a transaction that

171
00:14:01,680 --> 00:14:03,900
has an output at the script address.

172
00:14:04,560 --> 00:14:08,700
So I use this must pay to the script
with the datum I just defined.

173
00:14:09,120 --> 00:14:10,590
And then I must provide the value.

174
00:14:10,950 --> 00:14:17,400
So I take the value the amount from the
give parameters and then use this function

175
00:14:17,400 --> 00:14:20,359
here to convert that to a value in lovelace.

176
00:14:21,569 --> 00:14:24,930
The rest is as before I just
changed the log message.

177
00:14:25,319 --> 00:14:31,110
So I mentioned the amount, the
beneficiary and the deadline.

178
00:14:33,280 --> 00:14:35,770
Now for the grab, that's a bit more involved.

179
00:14:36,250 --> 00:14:39,730
Because there can be many
UTxOs at this vesting address.

180
00:14:40,180 --> 00:14:43,150
And some of them might not be suitable for me.

181
00:14:43,180 --> 00:14:48,100
Either because I am not the beneficiary or
because the deadline has not yet passed.

182
00:14:48,760 --> 00:14:51,190
So I grabbed the current time.

183
00:14:51,790 --> 00:14:54,780
I look up my own payment pub key hash.

184
00:14:55,890 --> 00:15:00,090
Then I get all the UTxOs
sitting at the script address.

185
00:15:00,450 --> 00:15:03,630
But of course not all of them may be usable for me.

186
00:15:03,660 --> 00:15:08,939
Either because I'm not the beneficiary or
because the deadline has not yet been reached.

187
00:15:09,510 --> 00:15:16,920
So I filter those UTxOs using this is suitable
helper function, which is defined down here.

188
00:15:17,595 --> 00:15:23,175
And its arguments it gets my own payment
pub key hash and the current time.

189
00:15:24,015 --> 00:15:27,895
Then the output that I found, the UTxO.

190
00:15:29,265 --> 00:15:30,495
And how do I do that?

191
00:15:30,705 --> 00:15:36,645
I check the datum of this output and there
are two cases, it can either just be a hash.

192
00:15:37,140 --> 00:15:41,070
This is actually the default case
as I mentioned several times before.

193
00:15:41,580 --> 00:15:46,050
When you create a transaction that has an output
at the script address, you are not required

194
00:15:46,050 --> 00:15:48,750
to include the datum, just the datum hash.

195
00:15:49,380 --> 00:15:53,905
So, there can be output's there that
just contain the hash, not the datum.

196
00:15:54,435 --> 00:16:01,334
But in such a case, I have no way to know whether
I'm the beneficiary and what the deadline is.

197
00:16:01,635 --> 00:16:06,194
Because I'm not able to compute the
actual datum when I just know the hash.

198
00:16:06,615 --> 00:16:09,375
So in that case, that's this left case.

199
00:16:10,005 --> 00:16:13,595
I can't do anything, so I forget about that UTxO.

200
00:16:14,025 --> 00:16:18,160
And if there is an actual datum
attached in the transaction.

201
00:16:19,120 --> 00:16:24,370
Then I try to deserialize that to the
right type, our vesting datum type.

202
00:16:24,460 --> 00:16:27,580
If that fails, I also drop the UTxO.

203
00:16:27,970 --> 00:16:36,730
And if it succeeds, I have to check that I am the
beneficiary and that the deadline lives in the past.

204
00:16:37,180 --> 00:16:40,300
So that now the current time is after the deadline.

205
00:16:41,550 --> 00:16:49,120
So at this point, the UTxOs contain all the
UTxOs where I'm the beneficiary and where

206
00:16:49,120 --> 00:16:51,270
the deadline has already been reached.

207
00:16:52,290 --> 00:16:59,220
And if I'm left with no UTxOs, then I just log
a message that there are no available gifts.

208
00:16:59,820 --> 00:17:05,355
And if there's at least one, then I try to
create a transaction that collects all of

209
00:17:05,355 --> 00:17:07,905
them at the same time in one transaction.

210
00:17:08,685 --> 00:17:19,035
Actually in the real world, depending on the setup
and the situation, there may be too many UTxOs for

211
00:17:19,035 --> 00:17:26,055
me to use them all as inputs to a single transaction
because transactions can only be of limited size.

212
00:17:26,835 --> 00:17:32,925
So to keep it simple, I forget about this case,
so I assume that there won't be that many gifts

213
00:17:32,925 --> 00:17:35,175
lying around for me, waiting for me to be grabbed.

214
00:17:36,995 --> 00:17:44,514
So I just get all the tx orefs, the
references of the UTxOs I want to collect.

215
00:17:45,355 --> 00:17:50,865
And I need to create this look
up that contains the UTxOs.

216
00:17:51,865 --> 00:17:54,834
And also the validator of the script.

217
00:17:55,675 --> 00:18:02,635
And then for the constraints of the transaction I
want to construct here I say that I want to spend

218
00:18:03,480 --> 00:18:10,230
the script output given by this reference where I
basically loop over all the references I found here.

219
00:18:10,379 --> 00:18:14,940
So I loop over all the UTxOs, the
suitable ones, that I want to collect.

220
00:18:15,090 --> 00:18:18,419
And I say that I want to spend each of those.

221
00:18:19,489 --> 00:18:24,170
So I just have to give the reference and then the
redeemer and we are always using the unit redeemer.

222
00:18:24,200 --> 00:18:29,929
Is a very common case, therefore there's a specific
value defined in the Plutus libraries called

223
00:18:29,929 --> 00:18:33,260
unit redeemer that gives me this unit redeemer.

224
00:18:34,250 --> 00:18:37,310
And now this is something new
that we haven't seen before.

225
00:18:38,449 --> 00:18:44,445
I conscious create a default transaction
with the infinite validity interval.

226
00:18:44,865 --> 00:18:50,985
Because now I must make sure that I
specify in the transaction that it's later

227
00:18:50,985 --> 00:18:53,235
than now, later than the current time.

228
00:18:54,135 --> 00:18:58,665
Because otherwise validation will fail
because then the validator won't be able to

229
00:18:58,725 --> 00:19:00,885
be sure that the deadline has already passed.

230
00:19:02,520 --> 00:19:07,830
And then as before I use one of these
variations of subnet transaction, where can

231
00:19:07,830 --> 00:19:10,560
specify the lookups and these constraints.

232
00:19:11,280 --> 00:19:14,520
And I wait for confirmation and then log a message.

233
00:19:16,020 --> 00:19:19,740
And finally, I just bundle up
these two endpoints as before.

234
00:19:19,740 --> 00:19:25,409
So I give the choice between
give and grab and then recourse.

235
00:19:25,649 --> 00:19:30,230
So once a give or grab has happened,
we can do another give or grab.

236
00:19:31,590 --> 00:19:33,510
Let's try this in the playground.

237
00:19:34,560 --> 00:19:37,200
First, let's add an additional wallet.

238
00:19:38,670 --> 00:19:44,030
And the idea is that wallet one makes
gifts to wallet two and wallet three.

239
00:19:44,740 --> 00:19:47,790
And then wallet two and
wallet three try to grab them.

240
00:19:48,300 --> 00:19:52,620
So let's start by finding the
skeleton of what I want to do.

241
00:19:53,190 --> 00:19:59,550
So wallet one starts with a give
and let's wait for one slot.

242
00:20:00,735 --> 00:20:02,334
And then there's another give.

243
00:20:04,215 --> 00:20:06,764
We wait for yet another slot.

244
00:20:08,834 --> 00:20:15,854
Normally it should be possible for wallet
one to make all the gifts in one slot.

245
00:20:16,334 --> 00:20:21,254
So it wouldn't need to wait in between, but
the way I defined the contracts, if you recall.

246
00:20:22,110 --> 00:20:26,940
After doing give or also a grab, I always
wait for confirmation of the transaction.

247
00:20:26,940 --> 00:20:29,010
Maybe I shouldn't have, but I did.

248
00:20:29,760 --> 00:20:35,070
So the endpoint won't be available again
until the transaction has been confirmed.

249
00:20:35,280 --> 00:20:40,060
So the way I've wrote it, we have to
wait in between these give actions.

250
00:20:41,379 --> 00:20:43,020
So let's do the third one.

251
00:20:45,120 --> 00:20:52,810
Now let's say the first two gifts are to wallet two.

252
00:20:53,610 --> 00:20:58,505
But with different deadlines,
let's say, slot 10 and slot 20.

253
00:20:59,105 --> 00:21:03,155
And the last one should be to
wallet three also with deadline...

254
00:21:03,665 --> 00:21:04,835
let's say slot 10.

255
00:21:06,185 --> 00:21:13,775
So, if wallet two and three wait until slot 11.

256
00:21:14,975 --> 00:21:20,475
They should be able to get the
gifts, but not the second one.

257
00:21:20,625 --> 00:21:24,195
The one that's only due in slot 20.

258
00:21:24,585 --> 00:21:27,225
So let's wait until slot 11.

259
00:21:27,945 --> 00:21:33,165
And then both two and three try to grab.

260
00:21:34,995 --> 00:21:38,265
And then let's wait another...

261
00:21:38,355 --> 00:21:40,735
I don't know, five slots just to be sure.

262
00:21:42,035 --> 00:21:42,975
So that's the idea.

263
00:21:44,145 --> 00:21:48,195
So now we encounter the first
problem in order to call give.

264
00:21:48,525 --> 00:21:55,115
We need to get the public key hash or the payment
public key hash of the wallets two and three.

265
00:21:56,025 --> 00:21:59,055
So how do we find out what those are?

266
00:21:59,745 --> 00:22:04,155
If we go to the repl and import wallet emulator.

267
00:22:05,895 --> 00:22:08,235
There's a type wallet defined.

268
00:22:09,794 --> 00:22:16,514
And that wraps a wallet ID and that
some opaque type can't directly handle.

269
00:22:19,004 --> 00:22:24,600
So, actually this wallet type represents
real wallets like a Daedalus wallet.

270
00:22:25,140 --> 00:22:29,250
But also a so-called mock wallets that
are, for example, used in the playground.

271
00:22:29,340 --> 00:22:32,110
So they are both combined under this wallet type.

272
00:22:33,160 --> 00:22:37,710
And, actually you can get to the mock wallets
once in the playground with the function

273
00:22:37,710 --> 00:22:42,235
called known wallet, and it takes an integer.

274
00:22:42,745 --> 00:22:46,495
So for example, known wallet
two, known wallet three.

275
00:22:47,785 --> 00:22:54,635
And there's also a function called mock wallet
payment pub key hash, which takes a wallet.

276
00:22:55,115 --> 00:22:59,220
And if it happens to be a mock wallet,
then it returns the payment pub key hash.

277
00:22:59,580 --> 00:23:03,870
And if it's a real wallet like Daedalus
wallet it would produce an error.

278
00:23:04,620 --> 00:23:11,340
So, we can get the payment pub key hash
of wallets two and three like this.

279
00:23:11,610 --> 00:23:12,960
So that's what we can use.

280
00:23:12,960 --> 00:23:14,650
So let's start with wallet two.

281
00:23:16,920 --> 00:23:22,340
So, let's say the first two
gives I said are to wallet two.

282
00:23:22,340 --> 00:23:26,130
And the third one is to wallet three.

283
00:23:28,510 --> 00:23:33,190
Now, the next problem we have is the deadlines,
but I already showed you in the first lecture

284
00:23:33,190 --> 00:23:42,160
for the auction example, how you can convert
slots to POSIX time in the playground.

285
00:23:42,790 --> 00:23:49,090
So let's find out what slot 10 and 20
are in POSIX time in the playground.

286
00:23:53,100 --> 00:23:57,510
So this is the POSIX time corresponding to slot 10.

287
00:23:57,600 --> 00:24:01,649
And this is the POSIX time corresponding to slot 20.

288
00:24:04,500 --> 00:24:08,810
I want it to use 10 for the
first and the third gift.

289
00:24:10,039 --> 00:24:11,779
And 20 for the second one.

290
00:24:16,200 --> 00:24:20,210
Now amounts, let's say each gift is 30 ADA.

291
00:24:23,130 --> 00:24:23,520
Okay.

292
00:24:23,520 --> 00:24:24,840
Let's go through it again.

293
00:24:25,230 --> 00:24:31,050
The first gift from wallet one to wallet
two with a deadline of slot 10 30 ADA.

294
00:24:31,860 --> 00:24:39,140
Second gift again to wallet two,
but deadline slot 20 30 ADA.

295
00:24:39,900 --> 00:24:44,774
Final gift to wallet three, deadline slot 10 30 ADA.

296
00:24:45,659 --> 00:24:47,850
Then we wait until slot 11.

297
00:24:47,850 --> 00:24:52,050
So that's after the slot 10 deadline,
but before this slot 20 deadline.

298
00:24:52,649 --> 00:24:54,500
And then wallet two and three try to grab.

299
00:24:54,959 --> 00:24:56,189
So let's see what happens.

300
00:24:59,729 --> 00:25:00,239
Okay.

301
00:25:00,360 --> 00:25:01,139
Looking good.

302
00:25:01,290 --> 00:25:03,209
So let's go through the transactions.

303
00:25:05,779 --> 00:25:10,980
Slot zero, that's again, the Genesis
transaction where the three wallets get

304
00:25:10,980 --> 00:25:13,620
their initial funds of 100 ADA each.

305
00:25:15,270 --> 00:25:17,070
Slot one is the first gift.

306
00:25:17,250 --> 00:25:24,600
So wallet one uses input its 100 ADA
has to pay a fee, get some change

307
00:25:24,690 --> 00:25:28,080
and 30 ADA end up in the script.

308
00:25:32,770 --> 00:25:33,640
Second gift.

309
00:25:35,040 --> 00:25:35,940
It's very similar.

310
00:25:38,400 --> 00:25:39,990
Third gift as well.

311
00:25:42,480 --> 00:25:45,770
And now these two, both happened in slot 12.

312
00:25:48,080 --> 00:25:52,160
So this is incidentally the grab of wallet three.

313
00:25:53,330 --> 00:25:59,150
So the input is this one UTxO, the one
gift waiting there for wallet three.

314
00:26:00,475 --> 00:26:03,175
And it ends up belonging to wallet three.

315
00:26:03,895 --> 00:26:08,425
And finally, this should be the
one belonging to wallet two.

316
00:26:09,294 --> 00:26:12,594
Also picks up the gift and gets the 30 ADA.

317
00:26:12,774 --> 00:26:18,504
But the third gift is still sitting
there because we aren't in slot 20 yet.

318
00:26:19,675 --> 00:26:23,754
We can try what happens if we
wait until slot 20 instead.

319
00:26:29,020 --> 00:26:33,940
So, let me change this from 11 to 21 and try again.

320
00:26:37,090 --> 00:26:40,750
So these should all look exactly the same.

321
00:26:42,760 --> 00:26:45,160
This is now wallet three that also looks the same.

322
00:26:46,080 --> 00:26:50,170
Wallet three of course could also
have grabbed at slot 11 already.

323
00:26:50,920 --> 00:26:54,430
But it doesn't matter if it waits until slot 21.

324
00:26:56,159 --> 00:27:00,450
But here now we see that the way we've
wrote the grab endpoint actually works.

325
00:27:00,450 --> 00:27:05,730
So if there's more than one gift available, all
of them are picked up in the same transaction.

326
00:27:06,240 --> 00:27:11,310
So now both gifts for wallet two are
available, because we are now in slot 21.

327
00:27:11,310 --> 00:27:16,919
So both deadlines have passed and
correctly our off-chain code same as a

328
00:27:16,919 --> 00:27:19,350
transaction that uses both of them as input.

329
00:27:19,980 --> 00:27:24,270
And then roughly 60 ADA end up in wallet two.

330
00:27:25,335 --> 00:27:28,274
So everything seems to work as expected.

331
00:27:30,375 --> 00:27:34,605
There's one thing I should point out
that I wrote the off-chain code, the

332
00:27:34,605 --> 00:27:41,314
wallet code, in a way that only submits a
transaction if it can actually grab the UTxO.

333
00:27:41,874 --> 00:27:48,254
For recall, I filter the UTxO to check that I
am the beneficiary and the deadline has passed.

334
00:27:49,215 --> 00:27:52,554
Which means that we don't
really exercise the validator.

335
00:27:52,845 --> 00:27:56,240
Because we only send transactions to the...

336
00:27:57,780 --> 00:28:01,980
to the blockchain that then get
validated that will pass validation.

337
00:28:02,190 --> 00:28:04,120
That's how we wrote the wallet code.

338
00:28:04,830 --> 00:28:09,430
So if you want to actually test the validator,
you would have to modify the wallet code.

339
00:28:09,430 --> 00:28:11,640
If you like, you can do that as an option homework.

340
00:28:11,640 --> 00:28:17,430
So remove these checks in the wallet
and just try to grab everything.

341
00:28:18,240 --> 00:28:21,940
And then it should fail if you
are not the beneficiary or if the

342
00:28:23,270 --> 00:28:24,855
deadline has not yet been reached.

343
00:28:25,485 --> 00:28:30,885
And then it should fail during validation,
not already just in the wallet, not

344
00:28:30,885 --> 00:28:32,385
even submitting the transaction.

345
00:28:35,145 --> 00:28:37,635
So we always have to be
careful to keep that in mind.

346
00:28:38,715 --> 00:28:40,735
Everybody of course can write off-chain code.

347
00:28:41,615 --> 00:28:43,710
So even though now it works.

348
00:28:43,740 --> 00:28:47,280
As long as you use the grab
endpoint that I provided.

349
00:28:47,430 --> 00:28:52,530
I mean, I wrote it in a way that you never
try to claim something that's not for you.

350
00:28:53,040 --> 00:28:58,140
But of course, somebody else could write different
piece of off-chain code that doesn't try that.

351
00:28:58,140 --> 00:29:00,450
And then if your validator is not correct.

352
00:29:00,510 --> 00:29:04,890
If it, for example, forgets to check
the beneficiary or the deadline and

353
00:29:04,890 --> 00:29:06,240
something could go horribly wrong.

354
00:29:07,544 --> 00:29:14,235
So we must keep that in mind that only because
it works for the endpoints you have provided

355
00:29:14,264 --> 00:29:18,195
doesn't mean that somebody else couldn't come
up with other endpoints where it doesn't work.

356
00:29:20,195 --> 00:29:20,435
Okay.

357
00:29:20,435 --> 00:29:27,304
So this is the vesting example, where we made
use of the context for the first time and

358
00:29:27,304 --> 00:29:34,205
where we made use of this valid time interval
in the transaction to implement a deadline.

